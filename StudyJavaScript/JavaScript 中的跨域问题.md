# JavaScript 中的跨域问题

## 由来

JavaScript 中的跨域问题来源于浏览器的 **同源策略**。

同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

同源策略规定了 **协议、域名、端口** 三个要一致，其中任何一个不一样都视为非同源，都会引起跨域问题。

> https://localhost:8888
>
> 协议： https
>
> 域名： localhost
>
> 端口号： 8888



## 引起的问题

1. 无法读取同源网页的 LocalStorge 、SessionStorge、Cookie
2. 无法解除非同源网页的 DOM
3. 无法向非同源网页发送 Ajax 请求



## 发生跨域问题的时机

前端是可以向非同源地址的后端发送请求的，但是在非同源地址的后端回传请求结果的时候就会被浏览器的同源策略拦下。

即跨域问题的发生时机在浏览器接收非同源地址的数据时。



## 解决方法

#### 1. JSONP

##### 原理

跨域问题是因为浏览器的同源策略，但是也有不受到同源策略束缚的东西，即 **script 、img 、link **三个 html 标签。这三个标签的 **src** 属性在加载资源的时候是不会产生同源策略的。

所以我们可以利用 script 标签的 src 属性去发送请求，将一个方法名`callback`传给后端，后端拿到这个方法名，将所需数据，通过字符串拼接成新的字符串`callback(所需数据)`，并发送到前端，前端接收到这个字符串之后，就会自动执行方法`callback(所需数据)`。

##### 缺点

1. 此方法需要前后端配合执行

2. 该方法只能使用 **get** 请求方式



#### 2. WebSocket

WebSocket 是 Html5 提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。

##### 原理

WebSocket 可以进行**跨域通信**，所以我们可以利用 WebSocket 协议进行数据请求。

为什么 WebSocket 可以跨域通信呢？是因为 WebSocket 根本不附属于同源策略，而且它本身就有意被设计成可以跨域的一个手段。



#### 3. Cors

Cors，全称是`Cross-Origin Resource Sharing`，意思是**跨域资源共享**，Cors一般是由后端来开启的，一旦开启，前端就可以跨域访问后端。

##### 原理

前端跨域访问到后端，后端开启Cors，发送`Access-Control-Allow-Origin: 域名` 字段到前端（其实不止一个），前端浏览器判断`Access-Control-Allow-Origin`的域名如果跟前端域名一样，浏览器就不会实行跨域拦截，从而解决跨域问题。



#### 4. Node接口代理

##### 原理

同源策略只能限制浏览器，是限制不到后端的，也就是 **前端 => 后端 **会被同源策略限制，但是 **后端 => 后端** 则不会被限制，所以可以通过Node接口代理，先访问已设置Cors的后端1，再让后端1去访问后端2获取数据到后端1，后端1再把数据传到前端。



#### 5. Nginx 反向代理

Nginx 反向代理有些类似Node接口代理，都是在中间代理。

##### 原理

如果我们直接在浏览器地址栏中，输入某接口地址，是不会产生跨域问题的。只有当我们在某域名的页面中，由该页面发起的接口请求。才可能会跨域。
Nginx 就类似于这个浏览器，它接收到外部对它的请求（ 注意，Nginx 只会接收别人对它的请求，而不会拦截浏览器的请求 ），再类似浏览器地址栏一样去请求某个接口。最后将请求到的内容返回回去。
前端利用host结合Nginx 实现跨域的运行流程：

```
发送请求：
浏览器 =》 host =》 Nginx =》 目标地址
接受数据：
服务器数据 =》 Nginx =》 浏览器
```

也就是说，Nginx 并不是通过监听浏览器的请求。而是作为一个服务器，接收外部对本机的请求。所以是先通过host，让请求指向本机，才会经过Nginx ，才能进行转发。

